# Ethereum

Ethereum is a blockchain platform for building decentralized applications: *application code and state* is stored on a blockchain   and transactions can cause code execution and update state, emit events, and write logs. Even frontend web interfaces can respond to events and read logs.
It's the most used platform for NFTs and ICOs (Initial Coin Offers). ICOs are based on ERC-20 token contract. It's useful in a scenario where a company seeking to raise money to create a new app, or service can launch an ICO as a way to raise funds. The interested investors receive a new cryptocurrency token issued by the company. This token may have some utility related to the product or service that the company is offering or represent a stake.

Ethereum allows to implemented **smart contracts** that are *decentralized, replicated, processed* on all the nodes on the network, without a central coordinator. The consensus mechanisms assure that all the nodes agree on the **results of the execution** and update the state in the same way so each node changes its own version of the ledger with the result of the smart contract evaluation. This is implemented by a a **distributed state machine** that define how change the **global state**, which is the status of all the smart contracts. A single transactions allows to change the global state. 

## Overview
As Bitcoin, Ethereum is based on a ***transaction-based deterministic state machine***: a virtual machine that applies changes to a global, replicated state. The state change is triggered by a transaction but Ethereum allows anyone to create its own **state transition functions** without imposing any script.
Differently from Bitcoin, Ehereym uses **accounts** that keep track of balance: the global shared state of Ethereum is stored in a **multitude of accounts**, from small objects interacting with one another through a message-passing paradigm. 

Compared to BTC, Ethereum is a a **public** and **permissionless** blockchain where the addresses are generated by *keys* and the transactions are signed through a *digital signatures*: in Ethereum blocks contain data and smart contracts, in Bitcoin blocks contain data and scripts. 
The **consensus algorithm** was Proof of Work until 2022, when Ethereum introduced Proof of Stake. As Bitcoin, Ethereum is deployed on a P2P Network: Kademlia i'ts used at P2P levelto discover peers.

### Accounts overview
Each account has an identifier of $20$ byte plus a state indicator. There are two maint ypes of accounts:
- **Externally owned (EOA)**:controlled by private keys so they don't have any code associated with them.
- **Contract accounts (CA)**: have code associated with them thus are controlled by the associated code.
The first type of accounts usually contains informations like *address, Ether balance, nonce (total transactions emitted from that account)* and are able to send transaction to transfer Ether or send transaction to trigger a smart contract. Differently from BTC, a transaction it's not based on UTXO but it's **account-based** (*as suggested by the balance and nonce*).

In case of **Externally Owned Account (EOA)**, the transaction format must include *Signature, Receiver address and the Amount*. 
In case of **Contract accounts (CA)**, the account contains:
- *contract code* 
- persistent storage for contract variables
- *balance*: like EOAs, contract accounts have an Ether balance and can receive/transfer Ether
- *nonce*: number of messages sent from this account

#### Smart Contract
A smart contract is a computer program in which the code cannot change after being deployed on the blockchain because it's execuded in parallel by all the *full nodes* of the network. The code must define a **deterministic computation** because the output of a smart contract must be the same for every node: to execute a contract, an *execution context* myst be provided. The context include data taken from the transaction that has activated the contract, the internal storage of the contract and information from block headers of the blockchain. 
We can distinguish three phases in the lifecycle of a smart contract:

1. **Creation**: To deploy a smart contract,the developer need to have an **EOA**: the transaction to create a contract involve using the information alredy defined for EOA transaction but with the *Receiver address* empty and with an extra field called `data` that contains the code of the smart contract. 
2. **Interaction**: The *EOA* calls a method of a smart contract through a transaction, enabling the execution and passing the required arguments. This phase uses a transaction with the *Receiver address* setted with the address of the contract and with the `data` field containing the method to call and the parameter to pass.
	Smart contracts are triggered by transactions from EOA or from messages from other smart contracts which call functions inside a contract, specifying the address of the contract and the parameters of the function. The transaction may even contains Ether to transfer to the smart contract.
	Contract account **cannot initiate a transaction by themselves**: when activated may call other contracts, but not themselves. This can lead to build complex execution paths.
	Upon reception of a transaction/message, the **Ethereum Virtual Machine (EVM**) is executed: it can perform different actions like *computation, write internal storage, send messages to another contract or create a new contract*.
	![[Pasted image 20230417115524.png]]
3. **Destruction**: this phase is triggered by a transaction with the *Receiver address* setted as the contract address and the `data` field containing the name of a method that calls the *self-destruction operation*.

So, overall, **EOAs** are a bridge between the external world to the internal state of Ethereum: any action is always set in motion by transactions fired from externally controlled accounts.

### Accounts and transactions insights
An account, as mentioned, contains:
- `nonce`: number of transactions sent/contracts created
- `balance`: owned *gwei (see Gas section)*
- `storageRoot`: i'ts the digest of the Ethereum's state as a hash of the root node of a Merkle Patricia trie.
- `codeHash:` hash of the code of contract account account. The `hash("")` function is used for external accounts.
Focusing on the **nonce**, the yellow paper states that is "*a scalar value equal to the number of transactions sent from this address or, in the case of accounts with associated code, the number of contract-creations made by this account*" so it's an *attribute of the address that originate the transaction* and not of the transaction itself.
The nonce allows also to records the order of the transactions, protecting against **transaction duplication** and **reply attacks** alongisde **double spending** from the same address. 
It's noticeable to remark that there are two types of *nonces*:
- **Transaction nonce**: not as Bitcoin nonce
- **Block nonce**: used by PoW, like Bitcoin's nonce

In case of **reply attacks**, because Ethereum stores account balances, the attacker takes any existing transaction and resend it on the network more and more time. All these replayed transactions try to withdraw funds from the same account and are considered valid because are signed with by the account's owner. Thus if the account has enough Ethers, the attack is successfully.
Ethereum prevents this with the using the **account/transaction nounce**: suppose that the `nonce` of the original transaction is $22$,after receiving the original one, the network does not accept another transaction from the same account with nonce setted as $22$ and this prevent the attacker to change the nonce because would invalidate the signaure of the transaction.
Each time an account sends a transaction the nonce is increased by 1 so it's used to enfroce the rules to consider a **transaction valid**. 
The transactions **must be in order** so a transaction with nonce 1 cannot be mined before one with nonce of 0. Also, transaction **cannot be skipped**: if a transaction has nonce 2 cannot be mined if the miner has not already sent transactions with nonce of 1 and 0. 

To **propagate a transaction**, Ethereum uses a *flooding approach*: the propagation starts with the node creating a *signed transaction* so the transaction is validated by each node and then it's transmitted to all other nodes that are directly connected to the originating node. On average, Ethereum node mantains connection to at least **13 other nodes**: each neighbor validate the transaction as soon as it receive it. If the received transaction is valid, they store a copy and propagate it to all their neighbords (*except the one it came from*). 

The process of **transaction mining** modify the global state of Ethereum: the balances of the involving accounts are modified and all contracts are activated by transactions/messages that are executed. The state of the accounts are updated and stored in a **Patricia Merkle tree** so a new  `stateRoot` is stored in the block header and the **Receipt Root** it's updated to contains the generated events. 
![[Pasted image 20230417122024.png]]
The winning miner will publish the block to the rest of the network,the other nodes execute the contracts and check the result. If the result is valid, they add the block to their blockchains: the entire network agrees on the *current balance, storage state, contract code, etc*, of every single account. 

### Ethereum State Machine
The state of the Ethereum network comprehends the **state of all its accounts**. A simplified version of an account state the *account address, balance and code and state of the variables for contract accounts.* 
![[Pasted image 20230417122348.png]]
Here a simplified version of **state transition fired by a transaction**:
![[Pasted image 20230417122434.png]]

### Gas
Every node in the network evaluates all transactions and store all the *contract state*: it's not possible to tell, just by looking at the program, whether it will take forever or not to execute. The program must be executed to verify this: due to Turing completeness, this may happen in Ethereum. 
To avoid the scenario in which a malicious user try to execute a never stopping contract-code, leading to a DoS (*because the EVM is a **single-threaded machine without scheduler***), Ethereum introduced the concept of ***gas***. 

The key idea is to *pay for contract execution*, giving payed *gas* to your smart contract: this make attacks expensive and allows the EVM to stop the execution when the contract goes out of gas. 
Each computational step has a fixed *gas fee*, as the *storage* that require also gas fees to perform contract actions. 
The *EVM* implement a **quasi-Turing-complete machine**: can run any program but only if the program has paied enough gas: at any time, there is a defined *computational limit* given by the amount of gas of the contract. 

#### Gas price
The explained model require to buy gas to run a smart contract, so purchasing a distributed, trustless computational power.
The gas price in Ether is determined by the *caller*: the price is based on the amount of Ether you are willing to spend per gas unit thus low prices means low priority. The gas prace is also measured in *"gwei (giga wei)"* where one $gwei$ correspond to 1 million $wei$. The unit of gas spent of each instruction is fixed: 
- **adding two numbers** : 3 gas 
- **computing a Keccak-256 hash**: 30 gas + 6 gas for each 256 bits of data being hashed 
- **sending a transaction**: 21,000 gas

Both **gas price** and **gas limit** are set for each transaction: the *gas limit* is the maximum amount of gas the sender is willing to pay so the fees are computed as $fees = gas_{price}*gas_{limit}$ which determine the max amount of *wei* the sender is willing to pay for the transaction. 
The fees are **rewards for miners** for the effort to run computations and validate transactions: the higher the gas price, the more likely miners will select the transaction.
1. if `gas_limit * gas_price > balance` then **halt** 
2. deduct `gas_limit * gas_price` from `balance` 
3. set `gas = gas_limit`
4. run code deducting from gas the amount required to run code 
5. after termination return remaining gas to balance
![[Pasted image 20230417124601.png]]

If the sender does not provide the necessary gas to execute the transaction, the transaction is *out of gas* and is considered **invalid**: the transaction aborts and the state reverts to previous state. Also `gas_limit * gas_price` is still deducted from balance because the node has spent the effort to run the calculations before running out of gas. 

The **gas limit** is not considered for internal transaction because is determined by the external creator of the original transction, by some EOA. Surely must be enough to carry out all the transactions, including any sub-executions that occur as a result of that transaction, such as contract-to-contract messages. 
If, in the chain of transactions and messages, a particular message execution runs *out of gas*, that message’s execution will revert, along with any subsequent messages triggered by the execution but the parent execution may not need to revert entirely.

#### Transaction format
The transaction format, sketched entirely in the following image, is serialized using the *RLP - Recursive Lenght Prefix* encoding scheme. 
![[Pasted image 20230417125024.png]]
The fields are:
- **TO**: 20-byte address of EOA or contract. There is no validation of the field so if invalid, Ether sent is burnt. Compared to bitcoin, there is only one output and not script; 
- **value**: the value is directly inserted in the transaction and there is no reference to the previous transaction output. This field is empty for the function invokation but contains a valid value for a payment. The value is transmitted to EOA to be added to the target address account or to contract accounts. In the last case, if no function is found, increase the balance of the contract, otherwise the function named in the data payload must be payable (*can accept Ether from the caller*). 
- **Data**: **to contracts accounts**: work as a function selector, allowing to unambiguously identify which function to invoke. The function arguments are encoded according to the rules for the various elementary types. **For contract creation transactions**, it allows to deploy a new contract on the blockchain where data payload contains the compiled bytecode which will create the contract.
- **gas limit**
- **gas price**
- **V,R,S**: represent the signature components of an ECDSA digital siginature of the original EOA. Allows to compute the address of the account sending the transaction.